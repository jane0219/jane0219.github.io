<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[javascript设计模式(-)构建型]]></title>
      <url>http://www.lxning.club/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(-)%E6%9E%84%E5%BB%BA%E5%9E%8B.html</url>
      <content type="html"><![CDATA[<h3 id="javascript设计模式-构建型"><a href="#javascript设计模式-构建型" class="headerlink" title="javascript设计模式(-)构建型"></a>javascript设计模式(-)构建型</h3><h4 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h4><a id="more"></a>
<ul>
<li>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象。<ul>
<li>函数对象： 凡是通过 new Function() 创建的对象都是函数对象</li>
<li>普通对象： 其他的都是普通对象</li>
</ul>
</li>
<li><p>构造函数(constructor)</p>
<pre><code class="javascript">  function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.sayName = function() { alert(this.name) } 
  }
  var xiaoning = new Person(&#39;xiaoning&#39;, 18);

</code></pre>
<ul>
<li>实例本身是没有构造函数属性（constructor）的，但是通过<strong>proto</strong>可以继承构造函数的原型对象上的constructor属性，其指向构造函数Person，所以xiaoning.constructor == Person</li>
<li>所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数 （Person.prototype.constructor == Person）<br><strong><code>注意</code></strong>：<br>  1，原型对象其实就是普通对象, 除了Function.prototype；<br>  2，Function.prototype是函数对象，但它很特殊，他没有prototype属性</li>
</ul>
</li>
<li>prototype和__proto__<ul>
<li>每个<strong>函数对象</strong>都有一个 <code>prototype</code> 属性，这个属性指向函数的原型对象</li>
<li>每个<strong>对象</strong>都有 <code>__proto__</code> 属性</li>
<li>所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身，即所有函数对象的proto都指向Function.prototype，所有构造器都继承了Function.prototype的属性及方法。</li>
</ul>
</li>
<li>原型链图解：<br><img src="/images/原型链.png" alt="Alt text"><br><img src="/images/原型链简图.png" alt="Alt text"></li>
</ul>
<h4 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h4><ul>
<li><strong>单一职责(SRP)</strong>：一个对象（方法）只做一件事情</li>
<li><strong>里氏替换(LSP)</strong>：子类可以代替父类</li>
<li><strong>依赖倒置（DIP）</strong>：面向接口编程，依赖接口不依赖方法，依赖抽象而不依赖具体</li>
<li><strong>接口隔离(ISP)</strong>：把大的接口拆分成小的接口（功能单一）</li>
<li><strong>迪米特法则(Law of Demeter )</strong>：即最少知道原则，函数中传入的参数越少越好</li>
<li><strong>开闭原则</strong>：面向扩展开放，面向修改关闭<br>总而言之：降低代码之间的耦合度，即解耦。</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul>
<li><strong>释义</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。例如：登录浮窗</li>
<li><strong>实现</strong>：先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回</li>
<li><strong>作用</strong>：保证这个类在运行期间只会被创建一个类实例</li>
<li><p><strong>实例</strong>：</p>
<pre><code>  var loader = (function(){
  var instance;
  function getInstance(){
      if(!instance){
          instance = new Create();
      }
      return instance;
  }
  return {
      getInstance: getInstance
  }
  })();
  function Create(){
          this.content = &#39;你好&#39;;
          this.title = &#39;标题&#39;;
  }
  loader.getInstance();//调用
</code></pre></li>
</ul>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ul>
<li><p><strong>简单工厂模式</strong>：</p>
<ul>
<li><strong>释义</strong>：由一个工厂对象决定创建某一种产品对象的实例.主要用于创建某一类对象，也叫静态工厂方法模式。</li>
<li><strong>实现</strong>：定义一个工厂方法，根据参数的不同返回不同类的实例</li>
<li><strong>作用</strong>：用来创建同一类对象</li>
<li><p><strong>事例</strong>：</p>
<pre><code>var Factory = function(type){
  switch (type){
      case &#39;basketball&#39;:
      return new basketball();
      case &#39;football&#39;:
      return new football();
  }
};
function Basketball(){
  this.name = &#39;篮球队&#39;;
  this.getMenberNum = function(){
      console.log(&#39;5个人&#39;);
  };
  this.getPlayAction = function(){
      console.log(&#39;投篮&#39;)
  };
}
function Football(){
  this.name = &#39;足球队&#39;;
  this.getMenberNum = function(){
      console.log(&#39;10个人&#39;);
  };
  this.getPlayAction = function(){
      console.log(&#39;射门&#39;)
  };
}
</code></pre></li>
<li><p><strong>图示</strong>：<br><img src="/images/简单工厂模式.png" alt="Alt text"></p>
</li>
<li><strong>缺点</strong>：如果我需要增加一个新的产品对象（如下例，新增一个排球队），那么我必须要对这个工厂对象进行修改， 以满足输出新的产品对象（球队），这就违背了开放-封闭原则。</li>
</ul>
</li>
<li><p><strong>工厂方法模式</strong>：</p>
<ul>
<li><strong>释义</strong>：将实际创建对象的工作推迟到子类中</li>
<li><strong>作用</strong>：这样核心类就变成了抽象类</li>
<li><strong>实现</strong>：在JavaScript中很难像传统面向对象那样去实现创建抽象类。所以在JavaScript中我们只需要参考它的核心思想即可。我们可以将工厂方法看作是一个实例化对象的工厂类。</li>
<li><p><strong>事例</strong>：</p>
<pre><code>//工厂方法我们使用安全模式
var Factory = function(type){
 if(this instanceof Factory){
     return new this[type]();
 }else{
     return new Factory(type);
 }
};
Factory.prototype = {
  basketball: function{
      this.name = &#39;篮球队&#39;;
      this.getMenberNum = function(){
          console.log(&#39;5个人&#39;);
      };
      this.getPlayAction = function(){
          console.log(&#39;投篮&#39;)
      };
  },
  football: function{
      this.name = &#39;足球队&#39;;
      this.getMenberNum = function(){
          console.log(&#39;10个人&#39;);
      };
      this.getPlayAction = function(){
          console.log(&#39;射门&#39;)
      };
  }
}
//合法调用
var football = new Factory(&#39;football&#39;);
var basketball = new Factory(&#39;basketball&#39;);
//非正常调用，新人往往会像调用一般函数那样，调用构造函数，安全模式就是为了使这一点得到保障
var football = Factory(&#39;football&#39;);
var basketball = Factory(&#39;basketball&#39;);
</code></pre></li>
<li><p><strong>图示</strong>：<br><img src="/images/工厂方法模式.png" alt="Alt text"></p>
</li>
</ul>
</li>
<li><p><strong>抽象工厂模式</strong>：</p>
<ul>
<li><strong>释义</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需制定它们具体的类</li>
<li><strong>实现</strong>：类簇一般用父类定义，并在父类中定义一些抽象方法，再通过抽象工厂让子类继承父类</li>
<li><strong>作用</strong>：用于对产品类簇的创建</li>
<li><p><strong>事例</strong>：</p>
<pre><code>var Factory = function(subType, superType){
  if(typeof Factory[superType] === &#39;function&#39;){
      function F(){};//过度类
      F.prototype = new Factory[superType]();
      subType.prototype = new F();
      subType.constructor = subType;
  }else{
      throw new Error(&#39;抽象方法不能调用&#39;)
  }
}
Factory.basketball = function() {
  this.type = &#39;basketball&#39;;
}
Factory.basketball.prototype = {
  getMenberNum: function() {
      return new Error(&#39;抽象方法不能调用&#39;);
  }
}
Factory.football = function() {
  this.type = &#39;football&#39;;
}
Factory.football.prototype = {
  getMenberNum: function() {
      return new Error(&#39;抽象方法不能调用&#39;);
  }
}
</code></pre><p>  Factory是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承。对抽象工厂方法添加抽象类的方法我们是通过点语法进行添加的。<br>下面我们来定义普通球类（子类）：</p>
<pre><code>function basketball(){
  this.name = &#39;篮球队&#39;;
  this.menberNum = 22;
}
Factory(basketball, &#39;basketball&#39;);
basketball.prototype.getMenberNum = function(){
  return this.menberNum;
}
var a = new basketball();
a.getMenberNum();
</code></pre></li>
<li><strong>缺点</strong>：不太容易扩展新产品，容易造成类层次复杂</li>
</ul>
</li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ul>
<li><strong>定义</strong>：将原型对象指向创建对象的类</li>
<li><strong>作用</strong>：使类之间共享原型对象的方法和属性</li>
<li><strong>实现</strong>：将可复用的，可共享的，耗时大的从基类中提出来放到原型中去，然后子类通过    <code>组合继承</code> 或 <code>寄生组合继承</code> 而将方法和属性继承下来，然后对于子类需要重写的方法进行重写。</li>
<li><p><strong>事例</strong>：</p>
<pre><code>  function Person(name) { 
      this.name = name; 
  } 
  Person.prototype.sayName = function(){
      console.log(this.name);
  }
  Person.prototype.changeName = function(){
      console.log(&#39;Person changeName function&#39;);
  }
  function Xiaoning(name){
      Person.call(this,name);
  }
  Xiaoning.prototype = new Person();
  Xiaoning.prototype.changeName = function(){
      console.log(&#39;Xiaoning changeName function&#39;);
  }
  var xiaoning =  new Xiaoning();
  xiaoning.changeName();

</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p>类式继承</p>
<pre><code> function SuperClass(){
         this.superValue = true
         this.colors = [&#39;blue&#39;, &#39;green&#39;];
 }
 SuperClass.prototype.getSuperValue = function(){
         return this.superValue;
 }
 function subClass(){
         this.subValue = true;
 }
 subClass.prototype = new superClass();//修改subClass的prototype对象的值，使subClass的prototype对象的__proto__指向superClass.prototype对象
 subClass.prototype.getSubValue = function(){
         return this.subValue;
 }
 var subClass1 = new subClass();
 subClass1.getSuperValue();//true
</code></pre><p> 问题：修改从父类继承来的引用类型的属性，会导致子类的其他实例全部被修改。</p>
<pre><code> var subClass1 = new subClass();
 var subClass2 = new subClass();
 subClass1.colors.push(&#39;red&#39;);
 console.log(subClass1.colors);//[&#39;blue&#39;, &#39;green&#39;, &#39;red&#39;]
 console.log(subClass2.colors);//[&#39;blue&#39;, &#39;green&#39;, &#39;red&#39;]
</code></pre></li>
<li><p>构造函数继承</p>
<pre><code> function SuperClass(value){
         this.superValue = value
 }
 SuperClass.prototype.getSuperValue = function(){
         return this.superValue;
 }
 function subClass(value){
         superClass.call(this,value);//在实例化的时候，把父类中的属性，复制到自己身上
         this.subValue = true;
 }
 subClass.prototype.getSubValue = function(){
         return this.subValue;
 }
 var subClass1 = new subClass(true);
 subClass1.getSuperValue();//true
 console.log( subClass1.superValue);//undefined
</code></pre><p> 问题：无法继承父类的原型上的方法和属性</p>
</li>
<li><p>组合式继承</p>
<pre><code> function SuperClass(value){
         this.superValue = value
 }
 SuperClass.prototype.getSuperValue = function(){
         return this.superValue;
 }
 function subClass(value){
         superClass.call(this,value);//在实例化的时候，把父类中的属性，复制到自己身上
         this.subValue = true;
 }
 subClass.prototype = new superClass();//修改subClass的prototype对象的值，使subClass的prototype对象的__proto__指向superClass.prototype对象
 subClass.prototype.getSubValue = function(){
         return this.subValue;
 }
 var subClass1 = new subClass(true);
 subClass1.getSuperValue();//true
 console.log( subClass1.superValue);//true
</code></pre><p> 解决了修改从父类继承来的引用类型的属性，不回影响其他实例的问题。<br> 但是这种继承方式，事实上执行了两遍父类的构造函数，消耗比较大。</p>
</li>
<li><p>寄生组合式继承</p>
<pre><code>function inheritPrototy(subClass,superClass){
    function F(){}//?为什么需要过度类
    F.prototype =  superClass.prototype;
    var f = new F();
    f.constructor = subClass;
    subClass.prototype = f;
}
function SuperClass(value){
    this.superValue = value
}
SuperClass.prototype.getSuperValue = function(){
    return this.superValue;
}
function subClass(value){
    superClass.call(this,value);
    this.subValue = true;
}
inheritPrototy(subClass, superClass);
subClass.prototype.getSubValue = function(){
    return this.subValue;
}
var subClass1 = new subClass(true);
subClass1.getSuperValue();//true
console.log( subClass1.superValue);//true
</code></pre></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript|设计模式|原型|原型链|构造函数|继承 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+Github搭建属于自己的博客]]></title>
      <url>http://www.lxning.club/Hexo+Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E8%AE%A9%E4%BD%A0%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84freestyle.html</url>
      <content type="html"><![CDATA[<h2 id="Hexo-Github搭建博客——让你拥有自己的freestyle"><a href="#Hexo-Github搭建博客——让你拥有自己的freestyle" class="headerlink" title="Hexo+Github搭建博客——让你拥有自己的freestyle"></a>Hexo+Github搭建博客——让你拥有自己的freestyle</h2><hr>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>博客最初的名称是<code>Weblog</code>，由web和log组成，即网络日记，后来喜欢新名词的人把它的发音改了一下，读成<code>we blog</code>，所以<code>blog</code>这个词被创造出来。即网志或网络日志。</p>
<a id="more"></a>
<p>相信大家平时在上网查阅资料或者学习的时候，也看了不少别人的博客，我猜这其中有很多人都想过去写自己的博客或者去建立自己风格的博客，但是真正去做的很少。博客大致分为三类：</p>
<ul>
<li><strong>其一</strong> ：就是不用花费财力和物力(编制程序)，只是到提供免费博客服务的网站上注册一个账号，然后进行自己的后台发表个人的一些思想</li>
<li><strong>其二</strong>：是自己购买空间、注册域名、编制程序来建立自己的博客，但这对于一个个人博客来说消耗还是蛮大的</li>
<li><strong>其三</strong>：就是可以自己编制程序来设计自己想要的风格的博客，然后把自己的代码托管到别人提供的空间上，这样既实现了博客风格的自主性，也是减少了不必要的开销（我们今天介绍的）。</li>
</ul>
<hr>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官方</a>定义</strong>：是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页<br><strong>基于</strong>：基于node.js开发，博客开发脚手架<br><strong>作者</strong>：台湾大学生<a href="https://zespia.tw/" target="_blank" rel="noopener">@tommy351</a><br><strong>源码</strong>：<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Github</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li><strong>node</strong>：<br>如果你没有安装node，请点击<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">这里</a>进行安装<br>如果已安装，请跳过这一步</li>
<li><strong>git</strong>：<br>如果你没有安装git，请点击<a href="https://git-scm.com/downloads/" target="_blank" rel="noopener">这里</a>进行安装<br>如果已安装，请跳过这一步</li>
<li><strong>hexo</strong><pre><code>npm install -g hexo-cli
</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4>安装完成hexo-cli以后，我们只需要执行三行命令：<pre><code>hexo init [folder] //视为node hexo-cli/entry.js init
cd [folder] //进入文件
npm install //安装依赖
git init //生成git本地仓库
</code></pre><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4>至此我们的博客脚手架就生成了最基本的一个结构，如下：<pre><code>.
├── _config.yml      // 站点配置文件，全局配置
├── node_modules     // 安装的插件以及hexo所需的一些nodejs模块
├── package.json     // 项目的依赖文件
├── scaffolds        // 模版文件，当创建新文章时，hexo会依据模版文件进行创建，主要用在你想在每篇文章都添加一些共性的内容的情况下
├── source           // 源文件，用来存放你的文章md文件，除了文章还有一些主要的资源，比如文章里的图片，文件等等
└── themes           // 存放主题文件
</code></pre>然后我们去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网主题</a>去选自己喜欢的主题，选中之后便可以安装主题，这里我安装的是 NexT 主题，hexo默认的是landscape，安装完之后会在 themes 下面产生一个 next 文件存放主题中的内容，文档结构大致下：<br><code>`</code></li>
</ul>
<p>.<br>├── README.en.md       // READEME 英文版<br>├── README.md          // READEME 中文文件<br>├── _config.yml        // 主题配置文件<br>├── bower.json<br>├── gulpfile.coffee<br>├── languages         // 多语言配置文件<br>├── layout            // 模板文件<br>├── package.json      // 项目的依赖文件<br>├── scripts           // 主题的脚本文件<br>├── source            // 主题的资源文件 CSS JS IMG…<br>└── test</p>
<pre><code>#### 配置
- **[Yaml](http://www.lxning.club/YAML基础语法简介)配置文件**: YAML是专门用来写配置文件的一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。
    - YAML对比XML:
可读性高 易于实现
和脚本语言的交互性好 
有一个一致的信息模型
以数据设计为重点，XML以标记为重点
    - 基本规则:
&gt; * 大小写敏感。
&gt; * 使用缩进表示层级关系。
&gt; * 缩进时不允许使用Tab键，只允许使用空格。
&gt; * 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可。

- **站点配置**： 站点的全局配置请移步[这里](http://www.lxning.club/Hexo全局配置_config.yml详解)
- **主题配置**：站点的主题配置敬请期待...
#### 书写和启动
- **书写**：
    - 你可以先找一个自己用的惯的markdown书写工具，把文章书写完成后，自己再进行保存或导出到自己的博客的文件夹下的/source/[你配置里选择的布局]/下面，因为这里才是在你生成的时候读取原始文章的地方。
    - **hexo new [title]**:  你可以进入博客文件夹，然后运行`hexo new [title]`,就可以生成一个模版文章，其中title就是文章的标题，例如： `hexo new hello`,那么则会在你的对应布局文件夹下生成一个hello.md的文件。你可以对他进行编写，然后发布。
    - **hexo-admin**:  hexo专门有一个插件hexo-admin，是hexo的后台管理系统，提供了在web UI下增删改查博客的功能。你也可以直接在后台中进行新建并且编写文章。如果你想使用它，首先你需要安装它
`npm install hexo-admin --save`
然后在hexo的_config.yml配置hexo-admin：
`
admin:
      username: lxning
      password_hash: [你的密码哈希值]
      secret: [你的密码]
      deployCommand: &#39;./hexo-generate.sh&#39;
`
至此admin后台管理系统的配置就好了，下面我们来看看启动。
- **启动**：
    - hexo博客网站启动：
    `hexo server`(可以简写成 `hexo s`)
    默认服务端口号是4000，即现在你查看：http://localhost:4000便可以查看你的博客了
    - hexo后台管理启动：
    `hexo server -d`(可以简写成`hexo s -d`)
#### 生成和部署
- **hexo g** : 每次执行hexo g命令时，hexo都会遍历主题文件中的source目录，这里的source主要包括css，fonts，js等文件，建立索引。
根据索引会把主题文件生成到public文件中，此时public文件是一个由html，js，css等内容制作的博客，也就是网页的根目录。
- **hexo d**: 通过部署，hexo d 将 public 文件夹的内容以 git 方式 push 到 github 的指定项目的指定分支，由 github 进行显示。当然，也可以部署到自己的域名上。
在部署前你需要与github（和Coding建立联系），在你的本地检查是否已经有ssh key`ls -al ~/.ssh`,如果没有，进行生成`ssh-keygen -t rsa -C &quot;your_email@example.com&quot;`，其中 your_email@example.com 为你在 GitHub（和Coding） 注册时的邮箱。然后进入`cd .ssh/id_rsa `把文件 id_rsa.pub里面的内容复制出来。
打开github（或者Coding）登陆后，点击设置-&gt;ssh key-&gt;添加，将内容粘贴上去。此时你的本地仓库和远程仓库就可以通过ssh地址进行通信了。

#### 模板引擎 
模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。
- **作用**：界面同数据分离，模板内容替换指定地方数据，实现业务和逻辑代码分离。
- **模板**：Hexo默认用[ejs](https://ejs.bootcss.com/)
- **解析**：
    - 概述：首先会解析 md 文件，然后根据 layout 判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个 html 页面。
    - 过程：从markdown到html的generate过程中做了一次数据解析，一次模版渲染：
两次的输入、渲染模板的引擎、输出如下：
![Alt text](http://coderunthings.com/images/howhexoworks/render.png)        
![Alt text](http://coderunthings.com/images/howhexoworks/post.png)

**`说明`**：
&gt; `hexo g`的过程中会首先解析markdown文件，然后生成一个对象，这里把这个对象称为article。
&gt; `第一次解析`的主要目的就是给这个对象添加title,content等属性。其中:
article.title, article.date, article.tags, article.categories等属性来自yml front的部分
article.content是markdown文章解析后的html片段
hexo项目目录下包含三个子目录，
source目录，写博客的主要工作目录。这个目录下存放的是我们的markdown文章以及js, images, css
themes目录，主题目录，定义了即将生成的html的layout, 和html中需要加载的css, js, images
public目录, hexo generate的最终输出目录。里面包含了整个博客网站的html, css, js, images
&gt; `第二次渲染`，需要引入对应模板文件格式的插件，如.ejs文件就需要使用hexo-render-ejs插件，.jade文件需要使用hexo-render-jade插件，而.sass文件则需要hexo-render-sass插件来转换成css文件。hexo的这一设计有点类似webpack中的loader。

#### SEO优化
首先，github pages是不会被百度收录的。所以这是一件很烦心的事，我们辛辛苦苦搭建的博客，居然百度抓不到，好难过！所以进行SEO优化就很有必要了。
其次除了github有pages服务外，Coding也是有pages服务的，而它是可以被百度收录的，所以我同时将代码托管到了github和Coding上，在解析域名的时候，默认线路解析到Coding上，境外线路解析到了github上。
但是这样还不够，我们需要进行一写配置和向百度和谷歌提交一下链接，和sitemap才有利于蜘蛛抓到我们。
安装下面的插件，在你进行hexo g的时候会生成对应sitemap:
</code></pre><p>npm install hexo-generator-sitemap –save<br>npm install hexo-generator-baidu-sitemap –save<br><code>`</code></p>
<p><strong>百度</strong>：</p>
<ul>
<li>登陆<a href="https://ziyuan.baidu.com/site/siteadd" target="_blank" rel="noopener">百度站长平台</a>，点击我的网站-&gt;站点管理-&gt;添加网站-&gt;输入你的域名。然后会要求你进行网站验证，根据指示把相应文件放到根目录下，然后部署上去，点击完成验证。会测试你是否验证成功。</li>
<li>自动推送：在全局配置里面把：<code>baidu_push: true</code>设为true，让他能自动推送给百度</li>
<li>sitemap: 将我们上一步生成的sitemap文件提交到百度就可以了~</li>
<li>验证：百度的效率比起谷歌会慢很多，查阅资料都说需要一周左右，你可以在百度浏览器中输入<code>site:www.lxning.club</code>进行验证是否被收录成功。</li>
</ul>
<p><strong>谷歌</strong>：</p>
<ul>
<li>登陆注册账号，然后验证网站，提交sitemap，跟百度是一样的操作。</li>
<li>验证：谷歌效率很快，今天提交，明天应该就能看到结果了。验证方式和百度是一样的</li>
</ul>
<p><strong>配置优化</strong></p>
<ul>
<li>全局配置里面的title,subtitle,tag等等，一定要配置好，这写都有利于SEO</li>
<li>在根目录配置文件中修改url为你的站点地址，文章的永久链接最好是固定的，默认是发布日期+title的，所以发布的文章你再更改了某篇文章后，链接就变了。这里我设置为:title.html，只要title不改变，链接就不会变。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 博客(Blog) </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog|Hexo|框架|github pages </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo全局配置_config.yml详解]]></title>
      <url>http://www.lxning.club/Hexo%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE_config.yml%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<h3 id="Hexo全局配置-config-yml详解"><a href="#Hexo全局配置-config-yml详解" class="headerlink" title="Hexo全局配置_config.yml详解"></a>Hexo全局配置_config.yml详解</h3><p>前一篇文章说了，hexo博客的主要配置就是_config.yml这个文件了，所以我们来详细看一下怎么配置它：</p>
<a id="more"></a>
<h4 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h4><p>这是站点的一些基础设置，对站点的SEO会是一个优化：</p>
<ul>
<li><strong>title</strong>： 站点名字，也就是html的title，会显示在浏览器标签上</li>
<li><strong>subtitle</strong>： 站点副标题，同时会显示在首页上</li>
<li><strong>description</strong>： 站点的描述，建议多放一些利于搜索的关键语句</li>
<li><strong>author</strong>： 作者</li>
<li><strong>language</strong>： 默认语言</li>
<li><strong>timezone</strong>： 站点时区，默认是电脑时间</li>
</ul>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><ul>
<li><strong>url</strong>： 站点网址</li>
<li><strong>roo</strong>：t 站点根目录</li>
<li><strong>permalink</strong>： 文章的网址链接，默认是:year/:month/:day/:title/，前面的时间就是你文章发表的时间，title是文章标题，例如: <code>http://lxning.club/2018/08/20/vue浅析/</code></li>
<li><strong>permalink_default</strong>：如果网址是次级目录，比如：<a href="http://example.com/blog，那么就要设置url为http://example.com/blog，并且root要设置为/blog/" target="_blank" rel="noopener">http://example.com/blog，那么就要设置url为http://example.com/blog，并且root要设置为/blog/</a></li>
</ul>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><strong>source_dir</strong>：source目录，默认值为source</li>
<li><strong>public_dir</strong>：public目录，静态网站生成的地方，默认值为public</li>
<li><strong>tag_dir </strong>：tag(标签)目录</li>
<li><strong>archive_dir</strong>：Archive目录</li>
<li><strong>category_dir</strong>：分类目录</li>
<li><strong>code_dir</strong>：代码目录</li>
<li><strong>i18n_dir</strong>：多语言i18n目录</li>
<li><strong>skip_render</strong>：不想被渲染的路径</li>
</ul>
<p>这些我都没有改过，默认的就行了</p>
<h4 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h4><ul>
<li><strong>new_post_name</strong>:  新建文章默认文件名，默认值为 :title.md，比如你执行命令hexo new hello，就会默认在_post目录下创建一个hello.md的文件</li>
<li><strong>default_layout</strong>:   默认布局</li>
<li><strong>external_link</strong>:   在新标签中打开一个外部链接，默认为true</li>
<li><strong>filename_case</strong>:   转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。</li>
<li><strong>render_drafts</strong>:   是否渲染_drafts目录下的文章，默认为false</li>
<li><strong>post_asset_folder</strong>:   是否启用Asset Folder，默认为false，至于什么是Asset Folder，后面有讲解。</li>
<li><strong>future</strong>:   是否显示未来日期文章，默认为true</li>
<li><strong>highlight</strong>:   代码块设置</li>
</ul>
<p>这一部分也可以基本不变，默认值就行。</p>
<h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><ul>
<li><strong>default_category</strong>:   默认分类，默认为无分类，当然你可以设置一个默认分类。</li>
<li><strong>category_map</strong>:   分类，不明白其作用</li>
<li><strong>tag_map </strong>:  标签，不明白其作用</li>
</ul>
<h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>Hexo使用的Moment.js来处理时间的</p>
<ul>
<li><strong>data_format</strong>: 日期格式，默认为MMM D YYYY，不过我将它改成了YYYY-MM-DD，符合个人口味，其他格式模版可以查看Moment.js</li>
<li><strong>time_format</strong>:  时间格式，默认为H:mm:ss</li>
</ul>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul>
<li><strong>per_page</strong>:   一页显示多少篇文章，0 为不分页，默认值为 10</li>
<li><strong>pagination_dir</strong>:  分页目录，默认值为page</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li><strong>theme</strong>:  主题配置，此处填上主题名就OK了，当然在themes目录下一定要有你配置的主题文件夹。</li>
<li><strong>deploy</strong>:  部署配置，将本地public目录也就是网站部署到服务器上的配置。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Hexo配置 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog|Hexo|框架|配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue浅析]]></title>
      <url>http://www.lxning.club/vue%E6%B5%85%E6%9E%90.html</url>
      <content type="html"><![CDATA[<h3 id="vue浅析"><a href="#vue浅析" class="headerlink" title="vue浅析"></a>vue浅析</h3><h4 id="vue是什么"><a href="#vue是什么" class="headerlink" title="vue是什么?"></a>vue是什么?</h4><p>Vue.js 是一个提供 MVVM 风格的双向数据绑定的前端主流框架，专注于 UI 层面。Vue.js 提供的核心是 MVVM 中的 VM，也就是 ViewModel。<br><a id="more"></a><br>ViewModel 负责连接 View 和 Model，保证视图和数据的一致性。如果你用过 AngularJS，你会发现 Vue.js 同时还借鉴了 Angular 的 directive<br>和 filter 的概念，但是 API 要简单易懂得多，整体也轻巧得多。在组件化这一点上，Vue.js 和 facebook 的 React.js 更为接近，可以定义可复<br>用和嵌套的组件类，并且可以在模板中声明式地使用组件。</p>
<h4 id="什么是MVVM？"><a href="#什么是MVVM？" class="headerlink" title="什么是MVVM？"></a>什么是MVVM？</h4><ul>
<li><p>Model：很简单，就是业务逻辑相关的数据对象，通常从数据库映射而来，我们可以说是与数据库对应的model。</p>
</li>
<li><p>View：也很简单，就是展现出来的用户界面。</p>
</li>
</ul>
<p>基本上，绝大多数软件所做的工作无非就是从数据存储中读出数据，展现到用户界面上，然后从用户界面接收输入，写入到数据存储里面去。所以，<br>对于数据存储（model）和界面（view）这两层，大家基本没什么异议。但是，如何把model展现到view上，以及如何把数据从view写入到model里，<br>不同的人有不同的意见。</p>
<p>MVC派的看法是，界面上的每个变化都是一个事件，我只需要针对每个事件写一堆代码，来把用户的输入转换成model里的对象就行了，这堆代码可<br>以叫controller。</p>
<p>而MVVM派的看法是，我给view里面的各种控件也定义一个对应的数据对象，这样，只要修改这个数据对象，view里面显示的内容就自动跟着刷新，<br>而在view 里做了任何操作，这个数据对象也跟着自动更新，这样多美。所以：</p>
<ul>
<li>ViewModel：就是与界面（view）对应的Model。因为，数据库结构往往是不能直接跟界面控件一一对应上的，所以，需要再定义一个数据对象<br>专门对应view上的控件。而ViewModel的职责就是把model对象封装成可以显示和接受输入的界面数据对象。</li>
</ul>
<p><img src="http://10.0.11.31:8090/download/attachments/8585941/3.png?api=v2" alt="Alt text"></p>
<h4 id="vue为什么出现？"><a href="#vue为什么出现？" class="headerlink" title="vue为什么出现？"></a>vue为什么出现？</h4><p>Vue.js 的最大特点就是上手简单：你不需要理解 Angular 的依赖注入是什么东东、不需要像 React 那样编译 JSX，在 Vue.js 的定义中，View<br>就是用户实际看到的 DOM 元素，而 Model 就是原生的JavaScript 对象。作为开发者，真正需要关注的只有 ViewModel，也就是 Vue.js 所提供<br>的 Vue 构建函数。<br>vue轻量，对于项目毫无压力。<br>vue让我们不用担心性能问题，虚拟dom让性能很是优化。<br>vue组件化思想，让前端开发更加有动力。</p>
<h4 id="大核心特征"><a href="#大核心特征" class="headerlink" title="大核心特征"></a>大核心特征</h4><h5 id="1-双向数据绑定："><a href="#1-双向数据绑定：" class="headerlink" title="1.双向数据绑定："></a>1.双向数据绑定：</h5><p>数据与视图的绑定与同步，最终体现在对数据的读写处理过程中，也就是 Object.defineProperty() 定义的数据 set、get 函数中。Vue 中定义<br>的函数为 defineReactive，在对数据进行读取时，如果当前有 Watcher（对数据的观察者吧，watcher 会负责将获取的新数据发送给视图），那<br>将该 Watcher 绑定到当前的数据上（dep.depend()，dep 关联当前数据和所有的 watcher 的依赖关系），是一个检查并记录依赖的过程。而在<br>对数据进行赋值时，如果数据发生改变，则通知所有的 watcher（借助 dep.notify()）。这样，即便是我们手动改变了数据，框架也能够自动将<br>数据同步到视图。</p>
<p><img src="http://10.0.11.31:8090/download/attachments/8585941/6.png?api=v2" alt="Alt text"></p>
<p><img src="http://10.0.11.31:8090/download/attachments/8585941/4.png?api=v2" alt="Alt text"></p>
<p><img src="http://10.0.11.31:8090/download/attachments/8585941/2.png?api=v2" alt="Alt text"></p>
<h5 id="2-组件化思想"><a href="#2-组件化思想" class="headerlink" title="2.组件化思想"></a>2.组件化思想</h5><p>在大型的应用中，为了分工、复用和可维护性，我们不可避免地需要将应用抽象为多个相对独立的模块（比如导航）。在较为传统的开发模式中<br>，我们只有在考虑复用时才会将某一部分做成组件；但实际上，应用类 UI 完全可以看作是全部由组件树构成的：</p>
<p><img src="http://10.0.11.31:8090/download/attachments/8585941/5.png?api=v2" alt="Alt text"></p>
<p>因此，在Vue.js的设计中将组件作为一个核心概念。可以说，每一个Vue.js应用都是围绕着组件来开发的。</p>
<p>注册一个Vue.js组件十分简单：</p>
<pre><code>    Vue.component(&#39;my-component&#39;, {
        // 模板
    template: &#39;&lt;div&gt;{{msg}} {{privateMsg}}&lt;/div&gt;&#39;,
    // 接受参数    
     props: {        
        msg: String 
    },
    // 私有数据，需要在函数中返回以避免多个实例共享一个对象
    data: function () {
        return {
            privateMsg: &#39;component!&#39;
        }
    }
})


</code></pre><p>注册之后即可在父组件模板中以自定义元素的形式调用一个子组件：</p>
<pre><code>&lt;my-component msg=&quot;hello&quot;&gt;&lt;/my-component&gt;

</code></pre><p>渲染结果：</p>
<pre><code>&lt;div&gt;hello component!&lt;/div&gt;

</code></pre><p>Vue.js的组件可以理解为预先定义好了行为的ViewModel类。一个组件可以预定义很多选项，但最核心的是以下几个：</p>
<ul>
<li>模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。</li>
<li>初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。<br>接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。参数默认是单向绑定（由上至下），但也可以显式地声明为双向绑定。</li>
<li>方法（methods）：对数据的改动操作一般都在组件的方法内进行。可以通过v-on指令将用户输入事件和组件方法进行绑定。</li>
<li>生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，比如created，attached，destroyed等等。在这些钩子函数中，<br>我们可以封装一些自定义的逻辑。和传统的MVC相比，可以理解为 Controller的逻辑被分散到了这些钩子函数中。</li>
<li>私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。由于全局注册资源容易导致命名冲突，一个组件可以声明自<br>己的私有资源。私有资源只有该组件和它的子组件可以调用。</li>
</ul>
<p>除此之外，同一颗组件树之内的组件之间还可以通过内建的事件API来进行通信。Vue.js提供了完善的定义、复用和嵌套组件的API，让开发者可以像<br>搭积木一样用组件拼出整个应用的界面。这个思路的可行性在Facebook开源的React当中也得到了印证。</p>
<h5 id="3-全局状态管理（VUEX）"><a href="#3-全局状态管理（VUEX）" class="headerlink" title="3.全局状态管理（VUEX）"></a>3.全局状态管理（VUEX）</h5><p>在Vue中，多组件的开发给我们带来了很多的方便，但同时当项目规模变大的时候，多个组件间的数据通信和状态管理就显得难以维护。而Vuex就此<br>应运而生。将状态管理单独拎出来，应用统一的方式进行处理，在后期维护的过程中数据的修改和维护就变得简单而清晰了。Vuex采用单向数据流的<br>方式来管理数据。用户界面负责触发动作（Action)进而改变对应状态（State），从而反映到视图（View）上。如下图所示：</p>
<p><img src="http://10.0.11.31:8090/download/attachments/8585941/1.png?api=v2" alt="Alt text"></p>
<ul>
<li>State<br>State负责存储整个应用的状态数据，一般需要在使用的时候在跟节点注入store对象，后期就可以使用this.$store.state直接获取状态。</li>
<li>Mutations<br>Mutations的中文意思是“变化”，利用它可以更改状态，本质就是用来处理数据的函数，其接收唯一参数值state。store.commit(mutationName)是<br>用来触发一个mutation的方法。需要记住的是，定义的mutation必须是同步函数，否则devtool中的数据将可能出现问题，使状态改变变得难以跟踪</li>
<li>Actions<br>Actions也可以用于改变状态，不过是通过触发mutation实现的，重要的是可以包含异步操作。如果选择直接触发的话，使用this.$store.dispatch<br>(actionName)方法。</li>
</ul>
<h5 id="4-虚拟DOM"><a href="#4-虚拟DOM" class="headerlink" title="4.虚拟DOM"></a>4.虚拟DOM</h5><p>你可能早就已经听说了 Vue.js 2.0。一个主要的令人兴奋的新特性就是更新页面的”虚拟DOM”的加入。</p>
<p>React 和 Ember 都使用了虚拟DOM来提升页面的刷新速度。为了理解其如何工作，让我们先讨论一下几个概念：<br>更新DOM的花费时间非常长，当我们使用 JavaScript 来改变页面的时候，浏览器不得不做一些工作来找到需要的DOM节点，并且做出类似这样的改变：</p>
<pre><code>document.getElementById(&#39;myId&#39;).appendChild(myNewNode);

</code></pre><p>在如今的应用程序的DOM中大概有成千上万的节点，因此更新所花费的时间就更长了。有很多不可避免的很小很频繁的更新拖慢了页面的速度。<br>我们可以使用 JavaScript 将DOM节点虚拟化表示<br>在一个HTML中，DOM节点通常表示如下：</p>
<pre><code>
&lt;ul id=&#39;myId&#39;&gt;
&lt;li&gt;Item 1&lt;/li&gt;
&lt;li&gt;Item 2&lt;/li&gt;
&lt;ul&gt;

</code></pre><p>DOM 节点也可以表示 JavaScript 中的对象，像这样：</p>
<pre><code>
// Pseudo-code of a DOM node represented as Javascript
Let domNode = {
tag: &#39;ul&#39;
attributes: { id: &#39;myId&#39; }
children: [
// where the LI&#39;s would go
]
};

</code></pre><p>这就是我们的“虚拟”DOM。<br>更新虚拟节点的开销不大</p>
<pre><code>
// This might be how we update the virtual DOM
domNode.children.push(&#39;&lt;ul&gt;Item 3&lt;/ul&gt;&#39;);

</code></pre><p>如果我们使用虚拟DOM，而不是直接在代码中调用类似 .getElementById 的 DOM API 方法，操作就会像改变 JS 对象一样非常的简单省时。<br>接下来，就是同步的把我们做的改变更新到真实DOM 中去，我们使用了一个很有效率的函数：</p>
<pre><code>
sync(originalDomNode, domNode);

</code></pre><p>就像在生活和 Web 开发中的每一件事，虚拟DOM有利也有弊。</p>
<ul>
<li>大小 - 其中之一就是更多的功能意味着代码包中更多行的代码。幸运的是，Vue.js 2.0 依旧比较小（当前版本 21.4kb），并且也正在<br>删除很多东西。</li>
<li>内存 -同样，虚拟DOM需要将现有的DOM拷贝后保存在内存中，这是一个在DOM更新速度和内存使用中的权衡。</li>
</ul>
<p>并不适用所有情况 -如果虚拟DOM可以一次性进行批量的修改是非常好的。但是如果是单独的、稀少的更新呢？这样的任何DOM更新都将会<br>使虚拟DOM带来无意义的预计算。<br>因此，如果某个项目只有较少数量的节点，那么使用虚拟DOM会带来速度上质的变化么？实际上更可能的是使其更慢了！<br>但是对于多数的单页面应用来说，它还是会带来提升的。</p>
<h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><p>Vue.js还有几个值得一提的特性：</p>
<ul>
<li>异步批量DOM更新：<br>当大量数据变动时，所有受到影响的watcher会被推送到一个队列中，并且每个watcher只会推进队列一次。这个队列会在进程的下一个<br>“tick” 异步执行。这个机制可以避免同一个数据多次变动产生的多余DOM操作，也可以保证所有的DOM写操作在一起执行，避免DOM读<br>写切换可能导致的layout。</li>
<li>动画系统：<br>Vue.js提供了简单却强大的动画系统，当一个元素的可见性变化时，用户不仅可以很简单地定义对应的CSS Transition或Animation效果，<br>还可以利用丰富的JavaScript钩子函数进行更底层的动画处理。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在发布之初，Vue.js原本是着眼于轻量的嵌入式使用场景。在今天，Vue.js也依然适用于这样的场景。由于其轻量（22kb min+gzip）、<br>高性能的特点。更重要的是，设计完备的组件系统和配套的构建工具、插件，使得Vue.js在保留了其简洁API的同时，也已经完全有能力<br>担当起复杂的大型应用的开发。</p>
<p>从诞生起到现在的一年半历程中，Vue.js经历了一次彻底的重构，多次API的设计改进，目前已经趋于稳定，测试覆盖率长期保持在100%，<br>GitHub Bug数量长期保持在个位数，并在世界各地都已经有公司/项目将Vue.js应用到生产环境中。</p>
]]></content>
      
        <categories>
            
            <category> vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue|框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[YAML基础语法简介]]></title>
      <url>http://www.lxning.club/YAML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B.html</url>
      <content type="html"><![CDATA[<h2 id="YAML基础语法简介"><a href="#YAML基础语法简介" class="headerlink" title="YAML基础语法简介"></a>YAML基础语法简介</h2><p>YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。</p>
<h3 id="YAML对比XML"><a href="#YAML对比XML" class="headerlink" title="YAML对比XML:"></a>YAML对比XML:</h3><p>可读性高 易于实现<br>和脚本语言的交互性好<br>有一个一致的信息模型<br>以数据设计为重点，XML以标记为重点</p>
<a id="more"></a>
<h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>YAML有以下基本规则：<br>1、大小写敏感<br>2、使用缩进表示层级关系<br>3、禁止使用tab缩进，只能使用空格键<br>4、缩进长度没有限制，只要元素对齐就表示这些元素属于一个层级。<br>5、使用#表示注释<br>6、字符串可以不用引号标注</p>
<h3 id="三种数据结构"><a href="#三种数据结构" class="headerlink" title="三种数据结构"></a>三种数据结构</h3><p>1、map，散列表<br>使用冒号（：）表示键值对，同一缩进的所有键值对属于一个map，示例：</p>
<pre><code>#YAML表示
age : 12
name : huang

#对应的Json表示
{&#39;age&#39;:12,&#39;name&#39;:&#39;huang&#39;}
</code></pre><p>也可以将一个map写在一行：</p>
<pre><code># YAML表示
{age:12,name:huang}

# 对应的Json表示
{&#39;age&#39;:12,&#39;name&#39;:&#39;huang&#39;}
</code></pre><p>2、list，数组<br>使用连字符（-）表示：</p>
<pre><code># YAML表示
- a
- b
- 12

# 对应Json表示
[&#39;a&#39;,&#39;b&#39;,12]
</code></pre><p>也可以写在一行：</p>
<pre><code># YAML表示
[a,b,c]

# 对应Json表示
[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</code></pre><p>3、scalar，纯量<br>数据最小的单位，不可以再分割。</p>
<h3 id="数据结构嵌套"><a href="#数据结构嵌套" class="headerlink" title="数据结构嵌套"></a>数据结构嵌套</h3><p>map和list的元素可以是另一个map或者list或者是纯量。由此出现4种常见的数据嵌套：<br>1、map嵌套map</p>
<pre><code># YAML表示
websites:
 YAML: yaml.org 
 Ruby: ruby-lang.org 
 Python: python.org 
 Perl: use.perl.org 

# 对应Json表示
{ websites: 
   { YAML: &#39;yaml.org&#39;,
     Ruby: &#39;ruby-lang.org&#39;,
     Python: &#39;python.org&#39;,
     Perl: &#39;use.perl.org&#39; } }
</code></pre><p>2、map嵌套list</p>
<pre><code># YAML表示
languages:
 - Ruby
 - Perl
 - Python 
 - c

# 对应Json表示
{ languages: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39;, &#39;c&#39; ] }
</code></pre><p>3、list嵌套list</p>
<pre><code># YAML表示
-
  - Ruby
  - Perl
  - Python 
- 
  - c
  - c++
  - java

# 对应Json表示
[ [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39; ], [ &#39;c&#39;, &#39;c++&#39;, &#39;java&#39; ] ]
</code></pre><p>除此以外，还可以如下表示该结构</p>
<pre><code># 方法2
- - Ruby
  - Perl
  - Python 
- - c
  - c++
  - java
</code></pre><pre><code># 方法3
- [Ruby,Perl,Python]
- [c,c++,java]
</code></pre><p>4、list嵌套map</p>
<pre><code># YAML表示
-
  id: 1
  name: huang
-
  id: 2
  name: liao
</code></pre><pre><code># 对应Json表示
[ { id: 1, name: &#39;huang&#39; }, { id: 2, name: &#39;liao&#39; } ]
</code></pre>]]></content>
      
        <categories>
            
            <category> yaml </category>
            
        </categories>
        
        
        <tags>
            
            <tag> yaml </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git命令和错误集锦]]></title>
      <url>http://www.lxning.club/Git%20%E5%91%BD%E4%BB%A4%E5%92%8C%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6.html</url>
      <content type="html"><![CDATA[<h3 id="Git-命令和错误集锦"><a href="#Git-命令和错误集锦" class="headerlink" title="Git 命令和错误集锦"></a>Git 命令和错误集锦</h3><hr>
<h4 id="前话：安装git"><a href="#前话：安装git" class="headerlink" title="前话：安装git"></a>前话：安装git</h4><p>官方网站下载：<br><a href="http://code.google.com/p/msysgit/downloads/list" target="_blank" rel="noopener">http://code.google.com/p/msysgit/downloads/list</a></p>
<p> 下载安装包后，打开执行，然后一路next.<br> 安装完成后，在桌面右键会出现 git bash here的标志和字样，说明安装成功。<br><a id="more"></a><br>然后我们就需要与远程的github相连接，才能进行本地管理。这仅需要三步：<br><code>$ git config --global user.name 你的github名称</code><br><code>$ git config --global user.email 你注册github的邮箱</code></p>
<p> 注意：这里的–global代表你电脑的所有本地仓库都会使用你的这个配置。</p>
<p>然后执行 $ssh-keygen -t rsa -C “你的邮箱”这里会让你输入密码，我们选择默认直接enter就行，不然之后可能会报错。<br>执行完后这时候会在你的电脑的 C/用户/Adiministor/.ssh/id_rsa.pub 生成这个key文件（id_rsa.pub）<br><img src="/images/1474722294367.png" alt="Alt text"></p>
<p>找到打开它，复制里面的代码然后到你的github上，右侧点击头像下面的setting<br><img src="/images/1474722248866.png" alt="Alt text"><br>然后点击左边栏的SSH and GPG key<br><img src="/images/1474722385417.png" alt="Alt text"><br>然后点击new SSH key进行key添加，把你电脑上的key粘贴到key下面的内容区，然后点 add ssh key<br><img src="/images/1474722569368.png" alt="Alt text"></p>
<p>至此你本地已经和github链接上了</p>
<hr>
<h4 id="（一）向远端提交项目："><a href="#（一）向远端提交项目：" class="headerlink" title="（一）向远端提交项目："></a>（一）向远端提交项目：</h4><h6 id="如果之前没有建立本地仓库的话先执行这里："><a href="#如果之前没有建立本地仓库的话先执行这里：" class="headerlink" title="如果之前没有建立本地仓库的话先执行这里："></a>如果之前没有建立本地仓库的话先执行这里：</h6><p>在桌面右击 git bash here   //（已经装过git了）<br>mkdir 文件夹名   //新建文件夹（作为本地仓库）<code>比如：mkdir project</code><br> cd project           //进入文件夹<br>git init             //初始化本地仓库</p>
<h6 id="如果已经有本地仓库了，从这部开始就行"><a href="#如果已经有本地仓库了，从这部开始就行" class="headerlink" title="如果已经有本地仓库了，从这部开始就行:"></a>如果已经有本地仓库了，从这部开始就行:</h6><p>git add 文件名/<em>  ( “ </em> ” 代表所有文件)<br>git commit –m “解释说明” （解释必须带上，避免进入文件编辑界面，如果进去了按ESC 然后：wq,再回车）<br>git remote add origin 远程地址 //建立远程连接<br>git push –set-upstream origin master<br>git push</p>
<p>至此如果没有出错的话文件就提交到远程版本库了</p>
<hr>
<h4 id="（二）建立分支："><a href="#（二）建立分支：" class="headerlink" title="（二）建立分支："></a>（二）建立分支：</h4><p>提醒：一般工作之后master上边的东西我们是没有权限更改的（那是QA的辖域），所以在master基础上需要建立自己的分支，在自己的分支上对项目进行更改。</p>
<h5 id="分值操作："><a href="#分值操作：" class="headerlink" title="分值操作："></a>分值操作：</h5><p>git checkout –b 分支名  //在master基础上复制一条分支来，并切换到新分支上<br>git checkout 分支名   //切换到指定分支<br>git branch    //查看分支<br>git branch –a   //查看包括远程的（包括别人建立的）所有分支<br>git merge master   //将自己的项目与master上的东西进行合并（为了避免别人也更改了项目，master东西被更改了）</p>
<hr>
<h4 id="（三）常用命令："><a href="#（三）常用命令：" class="headerlink" title="（三）常用命令："></a>（三）常用命令：</h4><p>ls  //显示所在文件夹的所有文件<br>mkdir // 新建一个文件夹<br>touch  //新建一个文件(不是文件夹)<br>git status   //查看当前状态<br>rm 删除  //（慎用）</p>
<hr>
<h4 id="（四）提交文件常见错误："><a href="#（四）提交文件常见错误：" class="headerlink" title="（四）提交文件常见错误："></a>（四）提交文件常见错误：</h4><p>1  执行git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:jane0219/test.git时报错：<br><code>fatal: remote origin already exists.</code><br>解决：执行git remote rm origin   //删除远程主机名</p>
<p>2.执行 git push 时报<br><code>fatal: The current branch master has no upstream branch.</code><br>解决：执行 git push –set-upstream origin master  //与远程master建立连接</p>
<p>3.执行git push –set-upstream origin master市报错：<br>        <code>! [rejected]        master -&gt; master (fetch first)  
error: failed to push some refs to &#39;git@github.com:jane0219/test.git&#39;</code></p>
<p>解决： git pull “远程地址” 再执行git add … //本地更改文件或者上传新文件前要先跟版本库的东西进行merge 合并，远程版本库有的东西本地仓库没有的话会报错（原因还不敢确定）</p>
<ol start="4">
<li>git pull 时报错：<br><code>refusing to merge unrelated histories</code></li>
</ol>
<p>解决：执行git pull origin master –allow-unrelated-histories //让git接受合并跟之前的项目的 无关项（以前的文件里没有的东西）</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git|错误|语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[markdown语法指南]]></title>
      <url>http://www.lxning.club/markdown%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97.html</url>
      <content type="html"><![CDATA[<h3 id="markdown语法指南"><a href="#markdown语法指南" class="headerlink" title="markdown语法指南"></a>markdown语法指南</h3><hr>
<h4 id="入门说明："><a href="#入门说明：" class="headerlink" title="入门说明："></a>入门说明：</h4><hr>
<p>定义：markdown 是一种轻量级标记语言，可以使用普通文本编辑器进行编辑的纯文本编辑语言。它可以把一篇纯文本文章转化为富文本，让读者得到清晰明了的阅读体验。<br>用途：markdown的语法简洁明了，所以很多人用它来写博客，就像我一样。</p>
<a id="more"></a>
<p>  它还可以用来编写说明文档，比如很多的readme文档都是用它写的。</p>
<p>除此之外因为我们还有markdownPad和马克飞象这样的工具，所以我们可以随意将自己写的文件输出为html文件、或者psd文件等。</p>
<h4 id="语法指南"><a href="#语法指南" class="headerlink" title="语法指南"></a>语法指南</h4><hr>
<h5 id="（一）特殊字符处理"><a href="#（一）特殊字符处理" class="headerlink" title="（一）特殊字符处理"></a>（一）特殊字符处理</h5><p>在html文件中，有两个字符需要特殊处理，那就是：&lt; 和&amp;   。“&lt;”符号在html里是用作一个标签的开始符号，而“&amp;”符号用于标记html实体，<code>&amp;lt;</code>代表”&lt;”。<br>而markdown让你更自然的书写字符，需要转换的它会处理好。它会保留原状。</p>
<hr>
<h5 id="（二）换行"><a href="#（二）换行" class="headerlink" title="（二）换行"></a>（二）换行</h5><p>这里的换行方法是要分情况的;</p>
<h6 id="（1）六级标题下的换行"><a href="#（1）六级标题下的换行" class="headerlink" title="（1）六级标题下的换行"></a>（1）六级标题下的换行</h6><p>只需要回车（enter）一下就可以了换行了，so easy~</p>
<h6 id="（2）其他格式下"><a href="#（2）其他格式下" class="headerlink" title="（2）其他格式下"></a>（2）其他格式下</h6><p>不是六级标题下的话就需要，在你现在所在行敲两个或两个以上空格，或者一个tab键，再回车才可以实现换行。</p>
<hr>
<h5 id="（三）文字加粗"><a href="#（三）文字加粗" class="headerlink" title="（三）文字加粗"></a>（三）文字加粗</h5><h6 id="（1）利用-“-”-加粗"><a href="#（1）利用-“-”-加粗" class="headerlink" title="（1）利用  “#”  加粗"></a>（1）利用  “#”  加粗</h6><p>在markdown里要实现六级标题很简单，只要在你所写的文字前面加上  “#”  就可以。一个  “#”  号代表一级标题，一次两个代表二级标题……（#后面要加一个空格）例如：</p>
<pre><code># 我是一级标题
## 我是二级标题
### 我是三级标题 
</code></pre><p>对应效果：<br><img src="/images/1474192521970.png" alt="Alt text"></p>
<h6 id="（2）利用下滑线-“-”或者-“—”"><a href="#（2）利用下滑线-“-”或者-“—”" class="headerlink" title="（2）利用下滑线  “===”或者 “—”"></a>（2）利用下滑线  “===”或者 “—”</h6><p>a.  “==”  出来的效果是一级标题<br>例如：</p>
<p><img src="/images/1474193802503.png" alt="Alt text"></p>
<p>b.  “–”出来的效果是二级标题<br><img src="/images/1474194148265.png" alt="Alt text"></p>
<p><span style="font-size:20px;">*</span>注意：无论是用双下滑线还是单下划线 ，都需要写两个或者两个以上才可以。</p>
<p>c.  用<strong>     </strong>包起来，比如：<br><code>**hello**</code><br>效果：<strong>hello</strong><br>d.  用<strong>       </strong>包起来，比如：<br><code>__hello__</code><br>效果：<strong>hello</strong><br>注：前后都是两个_或者*，如果是一个的话显示斜体。</p>
<hr>
<h5 id="（四）区块引用"><a href="#（四）区块引用" class="headerlink" title="（四）区块引用"></a>（四）区块引用</h5><p> markdown标记区块引用是使用类似email中的用&gt;的引用方式。如果你还熟悉在email新建中的引言部分，你就知道怎么在markdown中进行引用了。例如：</p>
<pre><code> &gt;假如生活欺骗了你 不要悲伤 反正明天也一样  --李晓宁
 &gt; 生活不止眼前的苟且 还有读不懂的诗和到不了的远方  --李晓宁
</code></pre><p>  对应效果：</p>
<blockquote>
<p>假如生活欺骗了你  不要悲伤  反正明天也一样  –李晓宁<br>生活不止眼前的苟且  还有读不懂的诗和到不了的远方  –李晓宁</p>
</blockquote>
<h6 id="（a）区块引用可以嵌套-比如："><a href="#（a）区块引用可以嵌套-比如：" class="headerlink" title="（a）区块引用可以嵌套  比如："></a>（a）区块引用可以嵌套  比如：</h6><pre><code>&gt;生活不止眼前的苟且
   &gt;&gt;还有读不懂的诗和到不了的远方
</code></pre><p>效果：</p>
<blockquote>
<p>生活不止眼前的苟且</p>
<blockquote>
<p>还有读不懂的诗和到不了的远方</p>
</blockquote>
</blockquote>
<h6 id="（b）引用的区块内也可以使用其他的-Markdown-语法，包括标题、列表、代码区块等："><a href="#（b）引用的区块内也可以使用其他的-Markdown-语法，包括标题、列表、代码区块等：" class="headerlink" title="（b）引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等："></a>（b）引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</h6><pre><code>&gt;###生活不止眼前的苟且
    &gt;&gt;好友读不懂的诗和到不了的远方
</code></pre><p>效果：</p>
<blockquote>
<h3 id="生活不止眼前的苟且"><a href="#生活不止眼前的苟且" class="headerlink" title="生活不止眼前的苟且"></a>生活不止眼前的苟且</h3><blockquote>
<p>还有读不懂的诗和到不了的远方</p>
</blockquote>
</blockquote>
<hr>
<h5 id="（五）列表"><a href="#（五）列表" class="headerlink" title="（五）列表"></a>（五）列表</h5><h6 id="（1）无序列表："><a href="#（1）无序列表：" class="headerlink" title="（1）无序列表："></a>（1）无序列表：</h6><p>a.用  “+”  号做标记（“+” 号后一定要有空格）  例如：<br><code>+ 我的生活</code><br><code>+ 我的爱好</code></p>
<p>效果：</p>
<ul>
<li>我的生活</li>
<li>我的爱好</li>
</ul>
<p>b. 用 “-” 号做标记（后面也要有空格） 例如：<br><code>- 我的生活</code><br><code>- 我的爱好</code></p>
<p>效果：</p>
<ul>
<li>我的生活</li>
<li>我的爱好</li>
</ul>
<p>c.用  “<em>”  做标记（记得空格） 例如：<br><code></code></em> 我的生活<code></code>* 我的爱好<code></code></p>
<p> 效果：</p>
<ul>
<li>我的生活</li>
<li>我的爱好</li>
</ul>
<h6 id="（2）有序列表"><a href="#（2）有序列表" class="headerlink" title="（2）有序列表"></a>（2）有序列表</h6><p>使用数字接着一个英文句号就OK  比如：</p>
<ol>
<li>小狗</li>
<li>小猫</li>
<li>小猪</li>
</ol>
<p>*注意：若是往列表里嵌入代码块，要首行做进至少8个空格或两个制表符。</p>
<hr>
<h5 id="（六）代码块"><a href="#（六）代码块" class="headerlink" title="（六）代码块"></a>（六）代码块</h5><h6 id="（1）用英文状态下的-nbsp-nbsp-引起来-例如："><a href="#（1）用英文状态下的-nbsp-nbsp-引起来-例如：" class="headerlink" title="（1）用英文状态下的 ``  &nbsp;&nbsp;  ``引起来,例如："></a>（1）用英文状态下的 ``  &nbsp;&nbsp;  ``引起来,例如：</h6><p><img src="/images/1474380803358.png" alt="Alt text"></p>
<p>效果：<br><img src="/images/1474380814707.png" alt="Alt text"></p>
<h6 id="（2）一个tab键或者三个以上空格之后再回车就会生成一个代码块，会自带高亮和背景。"><a href="#（2）一个tab键或者三个以上空格之后再回车就会生成一个代码块，会自带高亮和背景。" class="headerlink" title="（2）一个tab键或者三个以上空格之后再回车就会生成一个代码块，会自带高亮和背景。"></a>（2）一个tab键或者三个以上空格之后再回车就会生成一个代码块，会自带高亮和背景。</h6><p>比如：(注意前边空格)<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> <code>&lt;p&gt;nihao&lt;/p&gt;</code></p>
<pre><code>        &lt;p&gt;nihao&lt;/p&gt;
</code></pre><hr>
<h5 id="（七）插入图片"><a href="#（七）插入图片" class="headerlink" title="（七）插入图片"></a>（七）插入图片</h5><p> Markdown 使用一种和链接（一会我们会讲）很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。</p>
<h6 id="（1）行内式"><a href="#（1）行内式" class="headerlink" title="（1）行内式"></a>（1）行内式</h6><p>语法：! [图片标题] (图片地址)<br>例如：</p>
<pre><code>! [&quot;小女孩&quot;](/images/avatar.jpg)
</code></pre><p>效果：<br><img src="/images/avatar.jpg" alt="&quot;小女孩&quot;"></p>
<h6 id="（2）参考式"><a href="#（2）参考式" class="headerlink" title="（2）参考式"></a>（2）参考式</h6><p>语法：! [图片标题]  [id]<br><br>                [id]:url<br>例如：</p>
<pre><code>! [&quot;小女孩&quot;](/images/avatar.jpg)
</code></pre><p>效果：<br>![“小女孩”][id]<br>[id]:/images/avatar.jpg</p>
<hr>
<p>#####（八）超链接<br>超链接的语法格式跟插入图片的格式很是相似，它也有两种链接方式：行内式和参考式<br>语法分别和图片语法相似（这里就不做详细说明，相信大家都能懂）</p>
<h6 id="1-行内式"><a href="#1-行内式" class="headerlink" title="1.行内式"></a>1.行内式</h6><p>[链接文字] (链接地址)</p>
<h6 id="2-参考式"><a href="#2-参考式" class="headerlink" title="2.参考式"></a>2.参考式</h6><p>[链接文字]  <code>[</code>[id]<code>]</code><br><code>[</code>id<code>]</code>:链接地址</p>
<hr>
<h5 id="（九）分割线"><a href="#（九）分割线" class="headerlink" title="（九）分割线"></a>（九）分割线</h5><p>生成分割线的方式有很多种，下面给大家介绍几种通用的方式：<br><code>***</code>(三个或三个以上“ * ”连写)<br><code>---</code>（三个或三个以上“ - ”连写）(连接线)<br><code>___</code>（三个或三个以上“ _”连写）(下滑线)</p>
<h2 id="效果分别是："><a href="#效果分别是：" class="headerlink" title=" 效果分别是："></a> 效果分别是：</h2><hr>
<hr>
<h5 id="（十）表格"><a href="#（十）表格" class="headerlink" title="（十）表格"></a>（十）表格</h5><p>对于markdown我唯一觉得不怎么舒服的地方就是表格的编写，这是一个比较累人的地方，它的书写格式有点麻烦，在这个方面它就没有html简单了。下面是markdown书写表格的语法格式：</p>
<pre><code> |table|Are |cool|
 |-----|----|----|
 |name |age |addr|
</code></pre><p>效果如下：<br> |table|Are|cool|<br> |—–|—|—|<br> |name|age|addr|<br> |name|age|addr|</p>
<hr>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>以上是一些比较常用的markdown语法的使用介绍，希望对大家学习markdown能带来帮助。如果有好的提议，欢迎大家跟我一起交流。</p>
<p>本人博客：<a href="http://lxning.club" target="_blank" rel="noopener">http://lxning.club</a><br>邮箱：<a href="mailto:lxningdou@163.com" target="_blank" rel="noopener">lxningdou@163.com</a></p>
<p>出自：李晓宁</p>
]]></content>
      
        <categories>
            
            <category> markdown </category>
            
        </categories>
        
        
        <tags>
            
            <tag> markdown|语法 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
